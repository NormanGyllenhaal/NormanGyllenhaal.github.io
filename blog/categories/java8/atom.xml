<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java8 | Hi, I’m Yang Peng]]></title>
  <link href="http://yeangpeng.tech/blog/categories/java8/atom.xml" rel="self"/>
  <link href="http://yeangpeng.tech/"/>
  <updated>2016-02-18T16:06:02+08:00</updated>
  <id>http://yeangpeng.tech/</id>
  <author>
    <name><![CDATA[Yang Peng]]></name>
    <email><![CDATA[me@yangpeng.tech]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java8中的lambda表达式]]></title>
    <link href="http://yeangpeng.tech/blog/2015/04/21/java8-lambda/"/>
    <updated>2015-04-21T15:42:11+08:00</updated>
    <id>http://yeangpeng.tech/blog/2015/04/21/java8-lambda</id>
    <content type="html"><![CDATA[<p>2014年3月18日，Oracle终于发布Java8正式版。在新的版本里面加入了很多特性，
总共增加了55个新特性，其中最最吸引人的就是Lambdas表达式和Stream函数式编程，本文详细讲解这两个特性。</p>

<p>其他特性比如日期API，泛型，反射，注解，集合框架，并发，Nashorn引擎等等这里暂时就不详细介绍了。
具体可以参考：<a href="http://openjdk.java.net/projects/jdk8/features">http://openjdk.java.net/projects/jdk8/features</a></p>

<p>昨天参加了Oracle的Java8宣讲活动，有幸目睹了Simon Ritter的风采，写个总结来分享下。</p>

<p><strong>Java并发编程演变：</strong></p>





<table class="mytable">
    <tbody>
    <tr>
    <td>版本</td>
    <td>发布年份</td>
    <td>并发技术</td>
    </tr>
    <tr>
    <td>1.4</td>
    <td>2002</td>
    <td>java.lang.Thread</td>
    </tr>
    <tr>
    <td>5</td>
    <td>2004</td>
    <td>java.util.concurrent(jsr166)</td>
    </tr>
    <tr>
    <td>6</td>
    <td>2006</td>
    <td>Phasers, etc(jsr166)</td>
    </tr>
    <tr>
    <td>7</td>
    <td>2011</td>
    <td>Fork/Join Framework(jsr166y)</td>
    </tr>
    <tr>
    <td>8</td>
    <td>2014</td>
    <td>Project Lambda</td>
    </tr>
    </tbody>
</table>


<p>先来一个小例子见识下Java8的威力！<!--more--></p>

<p><strong>一，传统的外部迭代处理代码：</strong>
<code>java
List&lt;Student&gt; students = ...
double highestScore = 0.0;
for (Student s : students) {
    if (s.gradYear == 2011) {
        if (s.score &gt; highestScore) {
            highestScore = s.score;
        }
    }
}
</code></p>

<p>传统的外部迭代主要问题：</p>

<ul>
<li>程序员自己控制迭代，容易出问题！</li>
<li>顺序执行：迭代从开始到结束一个一个的顺序迭代元素</li>
<li>线程不安全，由于业务逻辑依靠可修改变量，容易产生竞态问题</li>
</ul>


<p><strong>二，基于Inner Classes的内部迭代：</strong>
<code>java
List&lt;Student&gt; students = ...
double highestScore = students.
        filter(new Predicate&lt;Student&gt;() {
            public boolean op(Student s) {
                return s.getGradYear() == 2011;
            }
        }).
        map(new Mapper&lt;Student,Double&gt;() {
            public Double extract(Student s) {
                return s.getScore();
            }
        }).
        max();
</code>
这种迭代形式已经具备了函数式特征。</p>

<p>优点：</p>

<ul>
<li>迭代，过滤和累加器由核心库完成</li>
<li>遍历操作可以并行执行</li>
<li>遍历可以延迟执行</li>
<li>线程安全 – 因为客户端的逻辑是无状态的</li>
</ul>


<p>缺点：</p>

<p>代码写的有点难看</p>

<p><strong>三，基于Lambdas的内部迭代：</strong>
<code>java
SomeList&lt;Student&gt; students = ...
double highestScore = students.
        filter(Student s -&gt; s.getGradYear() == 2011).
        map(Student s -&gt; s.getScore()).
        max();
</code></p>

<p>这种写法可以算是完美了：^_^</p>

<ul>
<li>可读性很好</li>
<li>更加抽象化</li>
<li>简单化后，自然就不容易出现bug了</li>
<li>不再依赖可变变量</li>
<li>很容易实现并行化</li>
</ul>


<p>进入正题 ~~</p>

<h3>Lambda篇</h3>

<p>Lambda表达式简单来讲就是匿名函数</p>

<ul>
<li>就像一个方法一样，它又参数列表，一个返回类型，抛出的异常集和一个执行体</li>
<li>但是跟方法不同的是，它不跟任何Class关联。</li>
</ul>


<p>也就是说，现在我们在Java的方法调用中不仅仅可以传值，还可以传动作(也就是函数)，这个有点类似于C语言的函数指针的概念了。</p>

<p>Lambda表达式的类型：</p>

<p>在Java中，到处都可以看到只有一个方法的接口，这种接口现在定义为函数式接口，
而Lambda表达式类型就是函数式接口，也就是只有一个方法的接口。</p>

<p>几个函数式接口的例子：
<code>java
interface Comparator&lt;T&gt; { boolean compare(T x, T y); }
interface FileFilter { boolean accept(File x); }
interface Runnable { void run(); }
interface ActionListener { void actionPerformed(…); }
interface Callable&lt;T&gt; { T call(); }
</code></p>

<p><strong>局部变量捕获：</strong></p>

<p>Lambda表达式可以引用上下文中的final等效局部变量。</p>

<p>final等效指的是变量的用法是final的，而不必声明为final，比如变量只赋值一次，那么它就是final等效的。
<code>java
void expire(File root, long before) {
    root.listFiles(File p -&gt; p.lastModified() &lt;= before);
}
</code></p>

<p><strong>this关键字：</strong></p>

<p>Lambda表达式中的this指的是包含这个Lambda的外部对象，而不是Lambda本身。
永远记住，Lambda表达式类型其实就是一个函数式接口。
<code>java
class SessionManager {
    long before = ...;
    void expire(File root) {
        // refers to 'this.before', just like outside the lambda
        root.listFiles(File p -&gt; checkExpiry(p.lastModified(), this.before));
    }
    boolean checkExpiry(long time, long expiry) { ... }
}
</code>
<strong>类型推断：</strong></p>

<p>很多情况下，编译器都可以根据目标函数式接口的方法签名来推断参数类型。
在Collections接口中有个sort接口：
<code>java
static T void sort(List&lt;T&gt; l, Comparator&lt;? super T&gt; c);
</code>
正常来讲，应该这么写：
<code>java
List&lt;String&gt; list = getList();
Collections.sort(list, (String x, String y) -&gt; x.length() - y.length());
</code>
借助类型推断，可以简化为：
<code>java
List&lt;String&gt; list = getList();
Collections.sort(list, (x, y) -&gt; x.length() - y.length());
</code>
<strong>方法引用：</strong></p>

<p>方法引用可以让我们将一个方法作为一个Lambda表达式重复利用。</p>

<p>比如，java.io.FileFilter作为一个函数式接口，仅有一个方法：
<code>java
boolean accept(File pathname);
</code>
正常的Lambda表达式用法：
<code>java
FileFilter x = File f -&gt; f.canRead();
</code></p>

<p>通过方法引用，可以简化为：
<code>java
FileFilter x = File::canRead;
</code></p>

<p>方法引用语法格式有以下三种：</p>

<pre><code>objectName::instanceMethod
ClassName::staticMethod
ClassName::instanceMethod
</code></pre>

<p>前两种方式类似，等同于把lambda表达式的参数直接当成instanceMethod|staticMethod的参数来调用。</p>

<p>比如 <code>System.out::println</code> 等同于 <code>x-&gt;System.out.println(x);</code>
<code>Math::max</code>等同于<code>(x, y)-&gt;Math.max(x,y)</code>。</p>

<p>最后一种方式，等同于把lambda表达式的第一个参数当成instanceMethod的目标对象，
其他剩余参数当成该方法的参数。比如<code>String::toLowerCase</code>等同于<code>x-&gt;x.toLowerCase()</code>。</p>

<p><strong>构造器引用：</strong></p>

<p>构造器引用语法如下：<code>ClassName::new</code>，把lambda表达式的参数当成ClassName构造器的参数 。
例如<code>BigDecimal::new</code>等同于<code>x-&gt;new BigDecimal(x)</code>。</p>

<p>和方法引用类似，构造器引用示例：</p>

<p>正常的Lambda表达式的构造器示例：
<code>java
Factory&lt;List&lt;String&gt;&gt; f = () -&gt; return new ArrayList&lt;String&gt;();
</code>
通过构造器引用，可以简化为：
<code>java
Factory&lt;List&lt;String&gt;&gt; f = ArrayList&lt;String&gt;::new;
</code></p>

<p><strong>接口扩展：</strong></p>

<p>在Java中，接口是不能随便新增方法的，因为接口中一旦增加方法，那么所以实现类都必须重写。
可以在Interface中使用default关键字来增加一个新的接口方法，并提供一个默认实现。
接口的实现类可以不用管，也可以覆盖这个方法。
<code>java
interface Collection&lt;E&gt; {
    default Stream&lt;E&gt; stream() {
        return StreamSupport.stream(spliterator());
    }
}
</code>
还可以使用@FunctionalInterface这个注解来注解函数式接口，如果接口中多于一个抽象方法，编译器肯定报错。</p>

<p>更甚至，在Java8中，在接口中也可以增加静态方法了。</p>

<h3>Stream篇</h3>

<p>许多的业务逻辑都需要聚集操作，比如按地区分类获取最优价值产品，按币种分类获取交易量。
之前版本的Java都是通过外部循环来完成这些操作，前面也说过了这种做法的很多弊端。</p>

<p>Java8给出完美解决方案：Lambda表达式+Stream API</p>

<p>Java中对Stream的定义：</p>

<pre><code>A sequence of elements supporting sequential and parallel aggregate operations.
</code></pre>

<p>我们来解读一下上面的那句话：</p>

<pre><code>- Stream是元素的集合，这点让Stream看起来用些类似Iterator；
– 可以支持顺序和并行的对原Stream进行汇聚的操作；
</code></pre>

<p>大家可以把Stream当成一个高级版本的Iterator。原始版本的Iterator，
用户只能一个一个的遍历元素并对其执行某些操作；高级版本的Stream，
用户只要给出需要对其包含的元素执行什么操作，
比如“过滤掉长度大于10的字符串”、“获取每个字符串的首字母”等，
具体这些操作如何应用到每个元素上，就给Stream就好了！（这个秘籍，一般人我不告诉他：））
大家看完这些可能对Stream还没有一个直观的认识，莫急，容我慢慢道来！</p>

<p>先解释下Stream管道：</p>

<p>Stream管道包含三部分，缺一不可：</p>

<ol>
<li>stream源</li>
<li>零个或多个中间操作</li>
<li>一个终止操作，产生一个结果或者一个副作用</li>
</ol>


<pre><code class="java">int sum = transactions.stream().
        filter(t -&gt; t.getBuyer().getCity().equals(“London”)).
        mapToInt(Transaction::getPrice).
        sum();
</code></pre>

<p>transactions.stream() -> stream源</p>

<p>filter/mapToInt -> 中间操作</p>

<p>sum() -> 产生结果</p>

<p>剖析Stream通用语法，再来看一个例子：
<code>java
//Lists是Guava中的一个工具类
List&lt;Integer&gt; nums = Lists.newArrayList(1,null,3,4,null,6);
nums.stream().filter(num -&gt; num != null).count();
</code>
<img src="http://yidaospace.qiniudn.com/0001.jpg" alt="" /></p>

<p>图片就是对于Stream例子的一个解析，可以很清楚的看见：原本一条语句被三种颜色的框分割成了三个部分。
红色框中的语句是一个Stream的生命开始的地方，负责创建一个Stream实例；
绿色框中的语句是赋予Stream灵魂的地方，把一个Stream转换成另外一个Stream，
红框的语句生成的是一个包含所有nums变量的Stream，进过绿框的filter方法以后，
重新生成了一个过滤掉原nums列表所有null以后的Stream；
蓝色框中的语句是丰收的地方，把Stream的里面包含的内容按照某种算法来汇聚成一个值，
例子中是获取Stream中包含的元素个数。</p>

<p>在此我们总结一下使用Stream的基本步骤：</p>

<ol>
<li>创建Stream；</li>
<li>转换Stream，每次转换原有Stream对象不改变，返回一个新的Stream对象（<strong>可以有多次转换</strong>）；</li>
<li>对Stream进行聚合（Reduce）操作，获取想要的结果；</li>
</ol>


<p><strong>stream源</strong></p>

<p>有很多方式可以产生stream源：</p>

<p>1. 从集合和数组产生：
<code>java
Collection.stream()  //接口default方法
Collection.parallelStream()  //接口default方法
Arrays.stream(T array) or Stream.of()  // 接口default方法或者是静态方法
</code>
2. 静态工厂方法：
<code>java
IntStream.range()
Files.walk()
</code></p>

<p>3. 使用Stream静态方法来创建Stream源</p>

<p>1) of方法：有两个overload方法，一个接受变长参数，一个接口单一值
<code>java
Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 5);
Stream&lt;String&gt; stringStream = Stream.of("taobao");
</code>
2) generator方法：生成一个无限长度的Stream，
其元素的生成是通过给定的Supplier（这个接口可以看成一个对象的工厂，每次调用返回一个给定类型的对象）
<code>java
Stream.generate(new Supplier&lt;Double&gt;() {
    @Override
    public Double get() {
        return Math.random();
    }
});
Stream.generate(() -&gt; Math.random());
Stream.generate(Math::random);
</code>
三条语句的作用都是一样的，只是使用了lambda表达式和方法引用的语法来简化代码。
每条语句其实都是生成一个无限长度的Stream，其中值是随机的。
这个无限长度Stream是懒加载，一般这种无限长度的Stream都会配合Stream的limit()方法来用。</p>

<p>4. iterate方法：也是生成无限长度的Stream</p>

<p>和generator不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。
其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环
<code>java
Stream.iterate(1, item -&gt; item + 1).limit(10).forEach(System.out::println);
</code>
这段代码就是先获取一个无限长度的正整数集合的Stream，然后取出前10个打印。千万记住使用limit方法，不然会无限打印下去。</p>

<p><strong>转换Stream：</strong></p>

<p>转换Stream其实就是把一个Stream通过某些行为转换成一个新的Stream。Stream接口中定义了几个常用的转换方法，下面我们挑选几个常用的转换方法来解释。</p>

<ol>
<li>distinct: 对于Stream中包含的元素进行去重操作（去重逻辑依赖元素的equals方法），新生成的Stream中没有重复的元素；</li>
<li>filter: 对于Stream中包含的元素使用给定的过滤函数进行过滤操作，新生成的Stream只包含符合条件的元素；</li>
<li>map: 对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素。
这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong和mapToDouble。
这三个方法也比较好理解，比如mapToInt就是把原始Stream转换成一个新的Stream，
这个新生成的Stream中的元素都是int类型。之所以会有这样三个变种方法，可以免除自动装箱/拆箱的额外消耗；</li>
<li>flatMap：和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中；</li>
<li>peek: 生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数；</li>
<li>limit: 对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素；</li>
<li>skip: 返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream；</li>
</ol>


<p><strong>性能问题</strong></p>

<p>有些细心的同学可能会有这样的疑问：在对于一个Stream进行多次转换操作，每次都对Stream的每个元素进行转换，
而且是执行多次，这样时间复杂度就是一个for循环里把所有操作都做掉的N（转换的次数）倍啊。其实不是这样的，
转换操作都是lazy的，多个转换操作只会在汇聚操作的时候融合起来，一次循环完成。我们可以这样简单的理解，
Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，
在汇聚操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。</p>

<p><strong>聚集（Reduce）Stream</strong></p>

<p>可变汇聚</p>

<p>可变汇聚对应的只有一个方法：collect，正如其名字显示的，它可以把Stream中的要有元素收集到一个结果容器中（比如Collection）。</p>

<p>通用的collect方法的定义（还有其他override方法）：</p>

<pre><code class="java">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,
        BiConsumer&lt;R, ? super T&gt; accumulator,
        BiConsumer&lt;R, R&gt; combiner);
</code></pre>

<p>先来看看这三个参数的含义：Supplier supplier是一个工厂函数，用来生成一个新的容器；
BiConsumer accumulator也是一个函数，用来把Stream中的元素添加到结果容器中；
BiConsumer combiner还是一个函数，用来把中间状态的多个结果容器合并成为一个（并发的时候会用到）</p>

<p>还有好消息，Java8还给我们提供了Collector的工具类–[Collectors]
<code>java
List&lt;Integer&gt; numsWithoutNull = nums.stream().filter(num -&gt; num != null).
       collect(Collectors.toList());
</code></p>

<p><strong>其他汇聚</strong></p>

<p>reduce方法：reduce方法非常的通用，后面介绍的count，sum等都可以使用其实现。
reduce方法有三个override的方法，本文介绍两个最常用的，
先来看reduce方法的第一种形式，其方法定义如下：
<code>java
Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);
</code>
接受一个BinaryOperator类型的参数，在使用的时候我们可以用lambda表达式来。
<code>java
List&lt;Integer&gt; ints = Lists.newArrayList(1,2,3,4,5,6,7,8,9,10);
System.out.println("ints sum is:" + ints.stream().reduce((sum, item) -&gt; sum + item).get());
</code>
可以看到reduce方法接受一个函数，这个函数有两个参数，第一个参数是上次函数执行的返回值（也称为中间结果），
第二个参数是stream中的元素，这个函数把这两个值相加，得到的和会被赋值给下次执行这个函数的第一个参数。</p>

<p>reduce方法还有一个很常用的变种：
<code>java
T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);
</code>
这个定义了初值，不是默认的第一个位初值。</p>

<p>其他参数:</p>

<ul>
<li>allMatch：是不是Stream中的所有元素都满足给定的匹配条件</li>
<li>anyMatch：Stream中是否存在任何一个元素满足匹配条件</li>
<li>findFirst: 返回Stream中的第一个元素，如果Stream为空，返回空Optional</li>
<li>noneMatch：是不是Stream中的所有元素都不满足给定的匹配条件</li>
<li>max和min：使用给定的比较器（Operator），返回Stream中的最大|最小值</li>
</ul>


<p>其他Tips：</p>

<p>Optional防止空指针异常，考虑一个常见的嵌套调用：
<code>java
String version = computer.getSoundcard().getUSB().getVersion();
</code>
在之前的Java中，我们对于空指针需要这么做：
<code>java
String version = "UNKNOWN";
if(computer != null){
    Soundcard soundcard = computer.getSoundcard();
    if(soundcard != null){
        USB usb = soundcard.getUSB();
        if(usb != null){
            version = usb.getVersion();
        }
    }
}
</code>
很显然，这个种做法太挫了！
Groovy语言里面有个?.的语法可以非常优雅的解决这个问题：
<code>groovy
String version = computer?.getSoundcard()?.getUSB()?.getVersion() ?: "UNKNOWN";
</code>
当然了，Java8不能示弱啊，所以就有了Optional：
<code>java
Optional computer = Optional.ofNullable(computer);
String name = computer.map(Computer::getSoundcard)
        .map(Soundcard::getUSB)
        .map(USB::getVersion)
        .orElse("UNKNOWN");
</code></p>

<p>关于Opational的更多信息，请参考<a href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html">Oracle官网</a></p>

<h3>结束语</h3>

<ol>
<li>Java需要lambda表达式和Stream API，充分发挥多核并行的优势，大大提高核心库的运行速度。</li>
<li>通过default关键字扩展接口来进行接口演变，同时保持向后兼容。</li>
<li>通过lambda表达式，大大简化了集合类的操作</li>
<li>Java8同时在语言、虚拟机、核心库方面做了大幅度的改进和优化，使得编程更简单，更快速。</li>
</ol>

]]></content>
  </entry>
  
</feed>
